<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animal Crawler</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1a1a;
            color: #f0f0f0;
            overflow: hidden;
            touch-action: manipulation;
        }
        .game-container {
            border: 4px solid #4a4a4a;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            background-color: #000;
            width: 100%;
        }
        canvas {
            background-color: #111;
            display: block;
        }
        .message-log {
            border: 2px solid #4a4a4a;
            min-height: 100px;
            overflow-y: scroll;
            padding: 10px;
            background-color: #2a2a2a;
            line-height: 1.5;
            font-size: 0.7rem;
        }
        .message-log::-webkit-scrollbar { width: 8px; }
        .message-log::-webkit-scrollbar-track { background: #2a2a2a; }
        .message-log::-webkit-scrollbar-thumb { background-color: #888; border-radius: 4px; border: 2px solid #2a2a2a; }
        .status-bar, .info-bar { background-color: #2a2a2a; border: 2px solid #4a4a4a; }
        .health-bar-bg, .xp-bar-bg { background-color: #555; border-radius: 4px; overflow: hidden; }
        .health-bar { background-color: #d9534f; height: 100%; transition: width 0.3s ease-in-out; }
        .xp-bar { background-color: #5bc0de; height: 100%; transition: width 0.3s ease-in-out; }
        .modal { background-color: rgba(0, 0, 0, 0.9); transition: opacity 0.5s; }
        .character-card {
            border: 2px solid #666;
            transition: all 0.2s ease-in-out;
        }
        .character-card:hover {
            border-color: #ffd700;
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.2);
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center h-screen p-2 sm:p-4">

    <!-- Game UI (Initially Hidden) -->
    <div id="game-ui" class="w-full max-w-7xl mx-auto flex flex-col lg:flex-row items-stretch gap-4 hidden h-full">
        <!-- Left Column: Canvas + Status -->
        <div class="flex flex-col gap-2 flex-grow h-3/5 lg:h-full">
            <div class="game-container flex justify-center items-center flex-grow">
                <canvas id="gameCanvas"></canvas>
            </div>
            <div class="status-bar p-2 lg:p-4 rounded-lg text-sm">
                <div class="flex justify-between items-center">
                    <span class="text-xs sm:text-sm">HP:</span>
                    <div class="w-1/2 mx-2"><div class="health-bar-bg w-full h-4 lg:h-5"><div id="playerHealthBar" class="health-bar" style="width: 100%;"></div></div></div>
                    <span id="playerHealthText" class="text-xs sm:text-sm font-bold">100/100</span>
                </div>
                 <div class="flex justify-between items-center mt-2">
                    <span class="text-xs sm:text-sm">XP:</span>
                    <div class="w-1/2 mx-2"><div class="xp-bar-bg w-full h-4 lg:h-5"><div id="playerXpBar" class="xp-bar" style="width: 0%;"></div></div></div>
                    <span id="playerXpText" class="text-xs sm:text-sm font-bold">0/100</span>
                </div>
            </div>
        </div>
        
        <!-- Right Column: UI -->
        <div class="flex flex-col gap-2 lg:w-80 xl:w-96 flex-shrink-0 h-2/5 lg:h-full">
            <div class="flex gap-2 w-full">
                 <div class="info-bar p-2 rounded-lg text-center w-1/3">
                    <h3 class="text-yellow-400 text-xs mb-1">Zone</h3><p id="zoneCounter" class="text-lg lg:text-2xl font-bold"></p>
                </div>

                <div class="info-bar p-2 rounded-lg text-center w-2/3">
                    <h3 class="text-yellow-400 text-xs mb-1">Character</h3>
                    <p class="text-sm lg:text-lg"><span id="playerSprite"></span> <span id="playerClass"></span></p>
                    <p class="text-xs lg:text-base text-gray-400">Level <span id="playerLevel">1</span></p>
                </div>
            </div>

            <div class="info-bar p-2 rounded-lg text-xs">
                 <div class="grid grid-cols-3 justify-around items-center text-center">
                    <div><h3 class="text-yellow-400 text-xs mb-1">Attack</h3><p id="playerAttack" class="text-sm lg:text-base"></p></div>
                    <div><h3 class="text-yellow-400 text-xs mb-1">Defense</h3><p id="playerDefense" class="text-sm lg:text-base"></p></div>
                    <div><h3 class="text-yellow-400 text-xs mb-1">Speed</h3><p id="playerSpeed" class="text-sm lg:text-base"></p></div>
                </div>
            </div>

            <div id="messageLog" class="message-log rounded-lg flex-grow"></div>
        </div>
    </div>

    <!-- Modals -->
    <div id="characterSelectionModal" class="modal fixed inset-0 flex items-center justify-center z-10 p-2 sm:p-4">
        <div class="text-center p-4 sm:p-6 bg-gray-900 rounded-xl border-4 border-yellow-500 shadow-lg w-full max-w-7xl h-[95vh] flex flex-col overflow-y-auto sm:overflow-y-hidden">
            <div id="characterGrid" class="grid grid-cols-3 sm:grid-cols-6 sm:grid-rows-3 gap-2 sm:gap-4 sm:flex-grow"></div>
        </div>
    </div>
    <div id="gameOverModal" class="modal fixed inset-0 items-center justify-center z-20 opacity-0 pointer-events-none hidden">
        <div class="text-center p-8 bg-gray-900 rounded-xl border-4 border-yellow-500 shadow-lg">
            <h2 id="gameOverTitle" class="text-5xl mb-4 text-red-500"></h2>
            <p id="gameOverText" class="text-xl mb-6"></p>
            <button onclick="resetGame()" class="px-6 py-3 bg-yellow-500 text-black rounded-lg text-lg hover:bg-yellow-400 transition-colors">Play Again</button>
        </div>
    </div>

    <!-- Touch Controls for Mobile -->
    <div id="touch-controls" class="fixed bottom-5 right-5 grid grid-cols-3 grid-rows-3 w-36 h-36 opacity-70 lg:hidden">
        <button id="touch-up" class="col-start-2 row-start-1 bg-gray-700 border-2 border-gray-500 rounded-md text-2xl active:bg-gray-500">▲</button>
        <button id="touch-left" class="col-start-1 row-start-2 bg-gray-700 border-2 border-gray-500 rounded-md text-2xl active:bg-gray-500">◀</button>
        <button id="move-controls" class="col-start-2 row-start-2 bg-gray-600 border-2 border-gray-500 rounded-full text-lg active:bg-gray-500">↔</button>
        <button id="touch-right" class="col-start-3 row-start-2 bg-gray-700 border-2 border-gray-500 rounded-md text-2xl active:bg-gray-500">▶</button>
        <button id="touch-down" class="col-start-2 row-start-3 bg-gray-700 border-2 border-gray-500 rounded-md text-2xl active:bg-gray-500">▼</button>
    </div>

    <script>
        // DOM Elements
        const elements = {
            canvas: document.getElementById('gameCanvas'),
            messageLog: document.getElementById('messageLog'),
            playerHealthBar: document.getElementById('playerHealthBar'),
            playerHealthText: document.getElementById('playerHealthText'),
            playerXpBar: document.getElementById('playerXpBar'),
            playerXpText: document.getElementById('playerXpText'),
            playerLevel: document.getElementById('playerLevel'),
            gameOverModal: document.getElementById('gameOverModal'),
            gameOverTitle: document.getElementById('gameOverTitle'),
            gameOverText: document.getElementById('gameOverText'),
            gameUI: document.getElementById('game-ui'),
            characterSelectionModal: document.getElementById('characterSelectionModal'),
            characterGrid: document.getElementById('characterGrid'),
            zoneCounter: document.getElementById('zoneCounter'),
            playerSprite: document.getElementById('playerSprite'),
            playerClass: document.getElementById('playerClass'),
            playerAttack: document.getElementById('playerAttack'),
            playerDefense: document.getElementById('playerDefense'),
            playerSpeed: document.getElementById('playerSpeed'),
        };
        const ctx = elements.canvas.getContext('2d');

        // --- Game Configuration ---
        let TILE_SIZE = 32;
        const MAP_WIDTH = 20;
        const MAP_HEIGHT = 15;
        const ACTION_COST = 100; // The amount of "action points" needed to take a turn

        const SPRITES = {
            WALLS: ['🌲', '🌳', '🌴', '🌿',],
            FLOOR: ' ',
            RUNNER: '🏃',
            PERSON: '🧍',
            CARTWHEELER: '🤸',
            WALKER: '🚶‍',
            JUGGLER: '🤾',
            LIFTER: '🏋️',
            PARTNERS: '🧑‍🤝‍🧑',
            GOLFER: '🏌️',
            KNEELER: '🧎‍',
	    BALLER: '⛹️',
	    FENCER: '🤺',
            PORTAL: '🕳️',
            CHEST: '🎁'
        };

        const BIOMES = [
            { name: 'a Savanna', walls: ['🌳', '🌿', '🌾'] },
            { name: 'the Jungle', walls: ['🌴', '🌱', '🍃','🌺'] },
            { name: 'a Forest', walls: ['🌲','🌳','🍄','🪵'] },
			{ name: 'a Graveyard', walls: ['🍂','🪵','🪦','🕸️'] },
			{ name: 'the Sky', walls: ['☁️','🌈','⛅','🌦️','🌧️'] }, 
            { name: 'a Desert', walls: ['🏜️', '🪨', '🌵'] },
            { name: 'the Mountains', walls: ['⛰️', '🗻', '🗿'] },
            { name: 'a Swamp', walls: ['🍃', '🪵', '🌱', '🐸'] },
            { name: 'a Meadow', walls: ['🌻','🌷','🌼','🌾','🌹'] },
            { name: 'the City', walls: ['🏢','🏘️','🏠','🏛️','🏬','🏭','🏫','🚕','🚧'] },
            { name: 'the Ocean', walls: ['🌊','🐚','🫧','🪸',]},
            { name: 'Space', walls: ['⭐','🌟','✨','🌙','🪐']},
			{ name: 'the Tundra', walls: ['🏔️','🧊','❄️','☃️']},
			{ name: 'a Tea Party', walls: ['🎀','🫖','🍰']},
			{ name: 'a Volcano', walls: ['🌋','🔥','🌑']}
        ];

        const FOODS = [
            { sprite: '🍎', healAmount: 35 },
            { sprite: '🍇', healAmount: 30 },
            { sprite: '🍌', healAmount: 25 },
            { sprite: '🍓', healAmount: 20 },
            { sprite: '🍒', healAmount: 15 }
        ];

        // --- Game Data ---
        const ORIGINAL_CHARACTERS = [
            // High Speed / High Risk
            { id: 10, name: 'Kangaroo',  sprite: '🦘', hp: 100, attack: 19, defense: 8,  speed: 22 }, // Original Def: 5
            { id: 12, name: 'Snake',     sprite: '🐍', hp: 90,  attack: 22, defense: 6,  speed: 19 }, // Original Def: 4
            { id: 0,  name: 'Tiger',     sprite: '🐅', hp: 109, attack: 20, defense: 9,  speed: 20 }, // Original Def: 6
            { id: 15, name: 'Leopard',   sprite: '🐆', hp: 135, attack: 16, defense: 11, speed: 20 }, // Original Def: 8
            { id: 3,  name: 'Horse',     sprite: '🐎', hp: 134, attack: 16, defense: 10, speed: 21 }, // Original Def: 7
            { id: 13, name: 'Butterfly', sprite: '🦋', hp: 120, attack: 12, defense: 12, speed: 24 }, // Original Def: 12
            // Dodge / Evasive
            { id: 9,  name: 'Flamingo',  sprite: '🦩', hp: 143, attack: 15, defense: 14, speed: 19 }, // Original Def: 10
            { id: 4,  name: 'Orangutan', sprite: '🦧', hp: 151, attack: 17, defense: 12, speed: 18 }, // Original Def: 9
            { id: 6,  name: 'Crocodile', sprite: '🐊', hp: 160, attack: 18, defense: 11, speed: 16 }, // Original Def: 8
            // Balanced / Bruisers
            { id: 2,  name: 'Camel',     sprite: '🐫', hp: 169, attack: 14, defense: 15, speed: 17 }, // Original Def: 11
            { id: 5,  name: 'Badger',    sprite: '🦡', hp: 179, attack: 15, defense: 16, speed: 15 }, // Original Def: 12
            { id: 14, name: 'Bison',     sprite: '🦬', hp: 190, attack: 16, defense: 14, speed: 15 }, // Original Def: 10
            // Tanks
            { id: 16, name: 'Beaver',    sprite: '🦫', hp: 185, attack: 11, defense: 19, speed: 13 }, // Original Def: 14
            { id: 7,  name: 'Hippo',     sprite: '🦛', hp: 204, attack: 12, defense: 18, speed: 14 }, // Original Def: 13
            { id: 1,  name: 'Elephant',  sprite: '🐘', hp: 213, attack: 11, defense: 20, speed: 13 }, // Original Def: 14
            { id: 8,  name: 'Buffalo',   sprite: '🐃', hp: 230, attack: 10, defense: 22, speed: 12 }, // Original Def: 15
            { id: 11, name: 'Turtle',    sprite: '🐢', hp: 196, attack: 9,  defense: 25, speed: 11 }, // Original Def: 16
            { id: 17, name: 'Sloth',     sprite: '🦥', hp: 250, attack: 11,  defense: 24, speed: 10  }, // Original Def: 16
        ];
        let CHARACTERS = JSON.parse(JSON.stringify(ORIGINAL_CHARACTERS));
        
        // --- Game State ---
        let map = [], player = {}, enemies = [], items = [], portal = {}, animations = [], gameOver = false, dungeonZone = 1, currentBiome = {}, turnCount = 0, isPlayerTurn = true;

        // --- Game Logic ---
        function createActor(type, x, y) {
            const powerZone = Math.max(0, dungeonZone - 1);
            const zoneMultiplier = Math.pow(1.1, powerZone);

            let baseStats;
            switch (type) {
                case SPRITES.RUNNER:      baseStats = { hp: 15, attack: 6,  defense: 0, vision: 11, speed: 30 }; break;
                case SPRITES.PERSON:      baseStats = { hp: 30, attack: 4,  defense: 1, vision: 5,  speed: 15 }; break;
                case SPRITES.CARTWHEELER: baseStats = { hp: 25, attack: 5,  defense: 1, vision: 8,  speed: 25 }; break;
                case SPRITES.WALKER:      baseStats = { hp: 10, attack: 5,  defense: 0, vision: 7,  speed: 12 }; break;
                case SPRITES.JUGGLER:     baseStats = { hp: 30, attack: 8,  defense: 2, vision: 9,  speed: 20 }; break;
                case SPRITES.LIFTER:      baseStats = { hp: 40, attack: 7,  defense: 4, vision: 4,  speed: 9 }; break;
                case SPRITES.PARTNERS:    baseStats = { hp: 65, attack: 14, defense: 2, vision: 9,  speed: 8 }; break;
                case SPRITES.GOLFER:      baseStats = { hp: 35, attack: 10, defense: 2, vision: 7,  speed: 18 }; break;
                case SPRITES.KNEELER:     baseStats = { hp: 50, attack: 3,  defense: 5, vision: 4,  speed: 9  }; break;
				case SPRITES.BALLER:	  baseStats = { hp: 10, attack: 9,  defense: 1, vision: 10, speed: 15 }; break;
				case SPRITES.FENCER:	  baseStats = { hp: 25, attack: 12, defense: 3, vision: 6,  speed: 10  }; break;
                case SPRITES.PORTAL:      return { type, x, y };
                case SPRITES.CHEST:       return { type, x, y };
                default:                  return { type, x, y };
            }
            
            const finalHp = Math.round(baseStats.hp * zoneMultiplier);
            return {
                type, x, y,
                hp: finalHp,
                maxHp: finalHp,
                attack: Math.round(baseStats.attack * zoneMultiplier),
                defense: Math.round(baseStats.defense * zoneMultiplier),
                vision: baseStats.vision,
                speed: baseStats.speed,
                ap: 0
            };
        }

        function generateDungeon() {
            const biomeWalls = currentBiome.walls;
            const wallChance = 0.45;
            map = Array.from({ length: MAP_HEIGHT }, () => 
                Array.from({ length: MAP_WIDTH }, () => 
                    Math.random() < wallChance ? biomeWalls[Math.floor(Math.random() * biomeWalls.length)] : SPRITES.FLOOR
                )
            );

            for (let i = 0; i < 4; i++) {
                let newMap = JSON.parse(JSON.stringify(map));
                for (let y = 1; y < MAP_HEIGHT - 1; y++) {
                    for (let x = 1; x < MAP_WIDTH - 1; x++) {
                        const wallNeighbors = countWallNeighbors(x, y, biomeWalls);
                        if (!biomeWalls.includes(map[y][x])) { 
                            if (wallNeighbors > 4) newMap[y][x] = biomeWalls[0];
                        } else {
                            if (wallNeighbors < 4) newMap[y][x] = SPRITES.FLOOR;
                        }
                    }
                }
                map = newMap;
            }
            
            for(let y = 0; y < MAP_HEIGHT; y++) {
                for(let x = 0; x < MAP_WIDTH; x++) {
                    if (x === 0 || x === MAP_WIDTH - 1 || y === 0 || y === MAP_HEIGHT - 1) {
                        map[y][x] = biomeWalls[0];
                    }
                }
            }

            const obstacleChance = 0.12; 
            for (let y = 1; y < MAP_HEIGHT - 1; y++) {
                for (let x = 1; x < MAP_WIDTH - 1; x++) {
                    if (map[y][x] === SPRITES.FLOOR && Math.random() < obstacleChance) {
                        map[y][x] = biomeWalls[Math.floor(Math.random() * biomeWalls.length)];
                    }
                }
            }
            connectRegions(biomeWalls);

            const floorTiles = [];
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    if (map[y][x] === SPRITES.FLOOR) { floorTiles.push({ x, y }); }
                }
            }
            
            for (let i = floorTiles.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [floorTiles[i], floorTiles[j]] = [floorTiles[j], floorTiles[i]];
            }

            enemies = [];
            items = [];
            
            const playerPos = floorTiles.pop();
            player.x = playerPos.x;
            player.y = playerPos.y;

            const portalPos = floorTiles.find(tile => {
                const dx = tile.x - player.x;
                const dy = tile.y - player.y;
                return (dx * dx + dy * dy) > 100; 
            }) || floorTiles.pop();

            if (portalPos) {
                 portal = createActor(SPRITES.PORTAL, portalPos.x, portalPos.y);
                 const portalIndex = floorTiles.findIndex(t => t.x === portalPos.x && t.y === portalPos.y);
                 if(portalIndex > -1) floorTiles.splice(portalIndex, 1);
            }
           
            const maxEnemies = Math.min(floorTiles.length -1, 2 + dungeonZone);
            for (let i = 0; i < maxEnemies && floorTiles.length > 0; i++) {
                const pos = floorTiles.pop();
                const enemyTypes = [
                    SPRITES.RUNNER, SPRITES.PERSON, SPRITES.CARTWHEELER, SPRITES.WALKER, 
                    SPRITES.JUGGLER, SPRITES.LIFTER, SPRITES.PARTNERS, SPRITES.GOLFER, 
		    SPRITES.KNEELER, SPRITES.BALLER, SPRITES.FENCER
                ];
                const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                enemies.push(createActor(type, pos.x, pos.y));
            }

            const maxItems = Math.min(floorTiles.length, 1 + Math.floor(dungeonZone / 2));
            for (let i = 0; i < maxItems && floorTiles.length > 0; i++) {
                const pos = floorTiles.pop();
                if (Math.random() > 0.7) {
                    items.push(createActor(SPRITES.CHEST, pos.x, pos.y));
                } else {
                    const randomFood = FOODS[Math.floor(Math.random() * FOODS.length)];
                    items.push({ type: 'food', ...randomFood, x: pos.x, y: pos.y });
                }
            }
        }
        
        function countWallNeighbors(x, y, biomeWalls) {
            let count = 0;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    const nx = x + i;
                    const ny = y + j;
                    if (nx < 0 || nx >= MAP_WIDTH || ny < 0 || ny >= MAP_HEIGHT || biomeWalls.includes(map[ny][nx])) {
                        count++;
                    }
                }
            }
            return count;
        }

        function connectRegions(biomeWalls) {
            const regions = [];
            const visited = Array.from({ length: MAP_HEIGHT }, () => Array(MAP_WIDTH).fill(false));
            function floodFill(x, y, region) {
                if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT || visited[y][x] || biomeWalls.includes(map[y][x])) return;
                visited[y][x] = true;
                region.push({ x, y });
                floodFill(x + 1, y, region); floodFill(x - 1, y, region);
                floodFill(x, y + 1, region); floodFill(x, y - 1, region);
            }
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    if (!visited[y][x] && map[y][x] === SPRITES.FLOOR) {
                        const newRegion = [];
                        floodFill(x, y, newRegion);
                        if (newRegion.length > 0) regions.push(newRegion);
                    }
                }
            }
            if (regions.length <= 1) return; 
            regions.sort((a, b) => b.length - a.length);
            const mainRegion = regions.shift();
            let allConnectedPoints = [...mainRegion];
            for (const region of regions) {
                let bestDist = Infinity, bestPointA = null, bestPointB = null;
                for (const pointA of region) {
                    for (const pointB of allConnectedPoints) {
                        const dist = Math.pow(pointA.x - pointB.x, 2) + Math.pow(pointA.y - pointB.y, 2);
                        if (dist < bestDist) {
                            bestDist = dist; bestPointA = pointA; bestPointB = pointB;
                        }
                    }
                }
                if (bestPointA && bestPointB) {
                    let cx = bestPointA.x, cy = bestPointA.y;
                    while (cx !== bestPointB.x || cy !== bestPointB.y) {
                         if (Math.abs(bestPointB.x - cx) > Math.abs(bestPointB.y - cy)) cx += Math.sign(bestPointB.x - cx);
                         else cy += Math.sign(bestPointB.y - cy);
                         if(biomeWalls.includes(map[cy][cx])) map[cy][cx] = SPRITES.FLOOR;
                    }
                }
                allConnectedPoints.push(...region);
            }
        }

        function isOccupied(x, y, ignorePlayer = false) {
            if (!ignorePlayer && player.x === x && player.y === y) return true;
            return enemies.some(e => e.x === x && e.y === y) || items.some(i => i.x === x && i.y === y) || (portal.x === x && portal.y === y);
        }

        function isWall(x, y) { return currentBiome.walls.includes(map[y][x]); }

        function movePlayer(dx, dy) {
            if (gameOver || !isPlayerTurn) return;
            const newX = player.x + dx, newY = player.y + dy;
            if (newX < 0 || newX >= MAP_WIDTH || newY < 0 || newY >= MAP_HEIGHT || isWall(newX, newY)) return;

            const targetEnemy = enemies.find(e => e.x === newX && e.y === newY);
            const targetItem = items.find(i => i.x === newX && i.y === newY);
            let actionTaken = false;

            if (targetEnemy) {
                attack(player, targetEnemy);
                actionTaken = true;
            } else if (targetItem) {
                if (targetItem.type === 'food') {
                    player.hp = Math.min(player.maxHp, player.hp + targetItem.healAmount);
                    logMessage(`You eat ${targetItem.sprite} and heal ${targetItem.healAmount} HP.`, '#99ff99');
                    const xpGained = Math.floor(targetItem.healAmount / 5);
                    addXp(xpGained);
                } else if (targetItem.type === SPRITES.CHEST) {
                    openChest();
                }
                items = items.filter(i => i !== targetItem);
                player.x = newX;
                player.y = newY;
                actionTaken = true;
            } else {
                player.x = newX;
                player.y = newY;
                actionTaken = true;
            }

            if (actionTaken) {
                if (player.x === portal.x && player.y === portal.y) { initNextZone(); return; }
                turnCount++;
                isPlayerTurn = false;
                processTurns();
            }
        }
        
        function processTurns() {
            while (true) {
                if(gameOver) return;
                let actorReady = false;
                while (!actorReady) {
                    player.ap += player.speed;
                    enemies.forEach(e => { if (e.hp > 0) e.ap += e.speed; });
                    if (player.ap >= ACTION_COST || enemies.some(e => e.ap >= ACTION_COST)) actorReady = true;
                }

                const readyActors = [player, ...enemies].filter(a => a.ap >= ACTION_COST && a.hp > 0);
                if (readyActors.length === 0) continue;

                readyActors.sort((a, b) => b.ap - a.ap); 
                const nextActor = readyActors[0];

                if (nextActor === player) {
                    player.ap -= ACTION_COST;
                    isPlayerTurn = true;
                    updateAnimations();
                    draw();
                    return; 
                } else {
                    const enemy = nextActor;
                    runEnemyAI(enemy);
                    enemy.ap -= ACTION_COST;
                    if (gameOver) { updateAnimations(); draw(); return; }
                }
            }
        }
        
        function openChest() {
            logMessage("You open a 🎁!", 'yellow');
            const bonusType = Math.random();
            
            if (bonusType < 0.25) {
                const atkBonus = Math.floor(Math.random() * 3) + 1;
                player.baseAttack += atkBonus;
                logMessage(`Your Attack permanently increased by ${atkBonus}!`, '#66ccff');
            } else if (bonusType < 0.5) {
                const defBonus = Math.floor(Math.random() * 3) + 1;
                player.baseDefense += defBonus;
                logMessage(`Your Defense permanently increased by ${defBonus}!`, '#66ccff');
            } else if (bonusType < 0.7) {
                const hpBonus = Math.floor(Math.random() * 11) + 10;
                player.maxHp += hpBonus;
                player.hp += hpBonus;
                logMessage(`Your Max HP permanently increased by ${hpBonus}!`, '#d9534f');
            } else if (bonusType < 0.85) {
                const spdBonus = Math.floor(Math.random() * 3) + 1;
                player.speed += spdBonus;
                logMessage(`Your Speed permanently increased by ${spdBonus}!`, '#a875ff');
            } else {
                const xpBonus = Math.floor(player.xpToNextLevel * (0.2 + Math.random() * 0.3));
                addXp(xpBonus);
                logMessage(`You found a burst of inspiration and gained XP!`, '#5bc0de');
            }
        }

        function attack(attacker, defender) {
            const attackerStats = getStats(attacker);
            const defenderStats = getStats(defender);
            
            let preDefenseDamage = (attacker.type)
                ? Math.floor(Math.random() * (Math.floor(attackerStats.attack) - Math.floor(attackerStats.attack / 2) + 1)) + Math.floor(attackerStats.attack / 2)
                : attackerStats.attack;

            const damageReduction = 100 / (100 + (defenderStats.defense * 10));
            const damage = Math.max(1, Math.round(preDefenseDamage * damageReduction));
            defender.hp -= damage;
            
            const attackerName = attacker.name || `The ${attacker.type}`;
            const defenderName = defender.name || `the ${defender.type}`;
            logMessage(`${attackerName} hits ${defenderName} for ${damage} damage!`, '#ff9999');

            if (defender.hp <= 0) {
                logMessage(`${defenderName} is defeated!`, '#99ff99');
                if (defender.type) {
                    animations.push({ x: defender.x, y: defender.y, frames: ['💥', '💥', ' '], currentFrame: 0 });
                    const xpGained = Math.floor(defender.maxHp / 4 + defender.attack);
                    addXp(xpGained);
                    enemies = enemies.filter(e => e !== defender);
                } else { loseGame(); }
            }
        }
        
        function addXp(amount) {
            if (!amount || amount <= 0) return;
            player.xp += amount;
            logMessage(`You gain ${amount} XP.`, '#5bc0de');
            if (player.xp >= player.xpToNextLevel) { levelUp(); }
        }

        function levelUp() {
            logMessage('LEVEL UP! You feel a surge of power!', '#ffd700');
            player.level++;
            player.xp -= player.xpToNextLevel;
            player.xpToNextLevel = Math.floor(100 * Math.pow(player.level, 1.1));
            const hpBonus = 10;
            player.maxHp += hpBonus;
            player.hp = player.maxHp;
            logMessage(`HP fully restored! Max HP increased by ${hpBonus}.`, '#99ff99');
            player.baseAttack++; logMessage('Your Attack increased!', '#66ccff'); 
            player.baseDefense++; logMessage('Your Defense increased!', '#66ccff'); 
        }
        
        function getStats(actor) {
            if(actor.type) return actor;
            return { attack: player.baseAttack, defense: player.baseDefense, speed: player.speed };
        }
        
        function runEnemyAI(enemy) {
            let moveX = 0, moveY = 0, decidedToMove = false;
            const dx = player.x - enemy.x, dy = player.y - enemy.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < enemy.vision) {
                if (distance < 1.5) { attack(enemy, player); return; }
                if (enemy.type === SPRITES.CARTWHEELER) {
                    moveX = Math.floor(Math.random() * 3) - 1;
                    moveY = Math.floor(Math.random() * 3) - 1;
                } else {
                    moveX = Math.sign(dx); moveY = Math.sign(dy);
                    if (Math.abs(dx) > Math.abs(dy)) moveY = 0; else moveX = 0;
                }
                decidedToMove = true;
            }

            if (decidedToMove) {
                const newX = enemy.x + moveX, newY = enemy.y + moveY;
                if (newX >= 0 && newX < MAP_WIDTH && newY >= 0 && newY < MAP_HEIGHT) {
                    if (!isWall(newX, newY) && !isOccupied(newX, newY, true)) {
                        enemy.x = newX; enemy.y = newY;
                    }
                }
            }
        }
        
        function initNextZone() {
            dungeonZone++; animations = [];
            currentBiome = BIOMES[Math.floor(Math.random() * BIOMES.length)];
            logMessage(`You fall through the hole into ${currentBiome.name}...`, '#ffd700');
            generateDungeon();
            player.ap = 0; isPlayerTurn = true;
            draw(); processTurns();
        }

        function loseGame() {
            gameOver = true; player.hp = 0;
            logMessage('You have been defeated...', '#ff0000');
            elements.gameOverTitle.textContent = "YOU DIED";
            elements.gameOverText.textContent = `You reached Zone ${dungeonZone}.`;
            elements.gameOverModal.classList.remove('opacity-0', 'pointer-events-none', 'hidden');
            elements.gameOverModal.classList.add('flex');
        }

        // --- Drawing & UI ---
        function resizeCanvas() {
            const container = elements.canvas.parentElement; // .game-container
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            // Calculate tile size based on the limiting dimension (width or height)
            const tileSizeW = Math.floor(containerWidth / MAP_WIDTH);
            const tileSizeH = Math.floor(containerHeight / MAP_HEIGHT);
            TILE_SIZE = Math.min(tileSizeW, tileSizeH);

            // Ensure tile size is not zero or negative
            TILE_SIZE = Math.max(1, TILE_SIZE);

            elements.canvas.width = MAP_WIDTH * TILE_SIZE;
            elements.canvas.height = MAP_HEIGHT * TILE_SIZE;

            if (player.hasOwnProperty('x')) {
                draw();
            }
        }
        
        function updateAnimations() {
            animations = animations.filter(anim => {
                anim.currentFrame++;
                return anim.currentFrame < anim.frames.length;
            });
        }

        function draw() {
            ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);
            ctx.font = `${TILE_SIZE * 0.8}px 'Press Start 2P'`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            
            const biomeWalls = currentBiome.walls;
            for (let y = 0; y < MAP_HEIGHT; y++) for (let x = 0; x < MAP_WIDTH; x++) {
                if (biomeWalls.includes(map[y][x])) ctx.fillText(map[y][x], x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2);
            }
            [...items, portal, ...enemies, player].forEach(actor => {
                if(actor) ctx.fillText(actor.sprite || actor.type, actor.x * TILE_SIZE + TILE_SIZE / 2, actor.y * TILE_SIZE + TILE_SIZE / 2);
            });
            animations.forEach(anim => {
                const frameSprite = anim.frames[anim.currentFrame];
                if (frameSprite) ctx.fillText(frameSprite, anim.x * TILE_SIZE + TILE_SIZE / 2, anim.y * TILE_SIZE + TILE_SIZE / 2);
            });
            updateUI();
        }

        function updateUI() {
            elements.playerHealthBar.style.width = `${Math.max(0, (player.hp / player.maxHp) * 100)}%`;
            elements.playerHealthText.textContent = `${Math.max(0, player.hp)}/${player.maxHp}`;
            elements.zoneCounter.textContent = `${dungeonZone}`;
            elements.playerSprite.textContent = player.sprite;
            elements.playerClass.textContent = player.name;
            const currentStats = getStats(player);
            elements.playerAttack.textContent = `${currentStats.attack}`;
            elements.playerDefense.textContent = `${currentStats.defense}`;
            elements.playerSpeed.textContent = `${currentStats.speed}`;
            elements.playerLevel.textContent = player.level;
            elements.playerXpBar.style.width = `${(player.xp / player.xpToNextLevel) * 100}%`;
            elements.playerXpText.textContent = `${player.xp}/${player.xpToNextLevel}`;
        }

        function logMessage(message, color = '#f0f0f0') {
            elements.messageLog.innerHTML += `<p style="color:${color};">> ${message}</p>`;
            elements.messageLog.scrollTop = elements.messageLog.scrollHeight;
        }

        function handleInput(e) {
            if (elements.gameUI.classList.contains('hidden')) return;
            if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); return; }
            if (e.key.startsWith('Arrow')) {
                e.preventDefault();
                switch (e.key) {
                    case 'ArrowUp': movePlayer(0, -1); break;
                    case 'ArrowDown': movePlayer(0, 1); break;
                    case 'ArrowLeft': movePlayer(-1, 0); break;
                    case 'ArrowRight': movePlayer(1, 0); break;
                }
            }
        }
        
        // --- Initialization ---
        function populateCharacterSelection() {
            CHARACTERS.sort((a,b) => a.id - b.id).forEach(char => {
                const card = document.createElement('div');
                card.className = 'character-card bg-gray-800 p-2 rounded-lg cursor-pointer flex flex-col justify-center h-full text-center';
                card.innerHTML = `
                    <div class="text-2xl sm:text-4xl lg:text-5xl">${char.sprite}</div>
                    <div class="font-bold text-yellow-400 mt-1 text-[10px] sm:text-sm">${char.name}</div>
                    <div class="text-gray-400 mt-1 text-[8px] sm:text-xs leading-tight">
                        <span>HP:${char.hp}</span> <span>ATK:${char.attack}</span><br>
                        <span>DEF:${char.defense}</span> <span>SPD:${char.speed}</span>
                    </div>
                `;
                card.onclick = () => initGame(char.id);
                elements.characterGrid.appendChild(card);
            });
        }

        function initMobileControls() {
            document.getElementById('touch-up').addEventListener('click', () => movePlayer(0, -1));
            document.getElementById('touch-down').addEventListener('click', () => movePlayer(0, 1));
            document.getElementById('touch-left').addEventListener('click', () => movePlayer(-1, 0));
            document.getElementById('touch-right').addEventListener('click', () => movePlayer(1, 0));

            const touchControls = document.getElementById('touch-controls');
            const moveControlsButton = document.getElementById('move-controls');

            moveControlsButton.addEventListener('click', () => {
                if (touchControls.classList.contains('right-5')) {
                    touchControls.classList.remove('right-5');
                    touchControls.classList.add('left-5');
                } else {
                    touchControls.classList.remove('left-5');
                    touchControls.classList.add('right-5');
                }
            });

            let touchStartX = 0, touchStartY = 0;
            elements.canvas.addEventListener('touchstart', e => {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            }, { passive: true });
            elements.canvas.addEventListener('touchend', e => {
                const dx = e.changedTouches[0].screenX - touchStartX;
                const dy = e.changedTouches[0].screenY - touchStartY;
                const swipeThreshold = 40;
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (Math.abs(dx) > swipeThreshold) movePlayer(dx > 0 ? 1 : -1, 0);
                } else {
                    if (Math.abs(dy) > swipeThreshold) movePlayer(0, dy > 0 ? 1 : -1);
                }
            }, { passive: true });
        }
        
        function resetGame() {
            elements.gameUI.classList.add('hidden');
            elements.gameUI.classList.remove('flex');
            elements.gameOverModal.classList.add('opacity-0', 'pointer-events-none', 'hidden');
            elements.gameOverModal.classList.remove('flex');
            gameOver = false; dungeonZone = 1; turnCount = 0;
            animations = []; player = {}; enemies = []; items = []; portal = {}; map = [];
            isPlayerTurn = true;
            CHARACTERS = JSON.parse(JSON.stringify(ORIGINAL_CHARACTERS));
            elements.characterGrid.innerHTML = '';
            populateCharacterSelection();
            elements.characterSelectionModal.classList.remove('opacity-0', 'pointer-events-none', 'hidden');
            elements.characterSelectionModal.classList.add('flex');
        }

        function initGame(charId) {
            const charData = CHARACTERS.find(c => c.id === charId);
            player = {
                ...charData,
                maxHp: charData.hp,
                baseAttack: charData.attack,
                baseDefense: charData.defense,
                level: 1, xp: 0, xpToNextLevel: 100, ap: 0
            };
            gameOver = false; dungeonZone = 1; turnCount = 0; isPlayerTurn = true;
            animations = [];
            currentBiome = BIOMES[Math.floor(Math.random() * BIOMES.length)];
            elements.messageLog.innerHTML = '';
            elements.characterSelectionModal.classList.add('opacity-0', 'pointer-events-none');
            elements.gameUI.classList.remove('hidden');
            elements.gameUI.classList.add('flex');
            generateDungeon();
            resizeCanvas();
            logMessage(`You begin your adventure in a ${currentBiome.name}...`, '#aaa');
            processTurns();
        }

        window.addEventListener('keydown', handleInput);
        window.onload = () => {
             populateCharacterSelection();
             initMobileControls();
             window.addEventListener('resize', () => {
                resizeCanvas();
             });
        };
    </script>
</body>
</html>










